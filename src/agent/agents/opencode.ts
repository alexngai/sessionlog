/**
 * OpenCode Agent
 *
 * Implementation of the Runlog agent interface for OpenCode.
 * Handles JSON export format with messages array, OpenCode-specific
 * plugin-based hook installation, and session lifecycle management.
 *
 * OpenCode uses `opencode export` CLI command for transcript access.
 * Sessions are stored in JSON format: { info: {...}, messages: [...] }
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import {
  AGENT_NAMES,
  AGENT_TYPES,
  type HookInput,
  type Event,
  type TokenUsage,
  EventType,
  emptyTokenUsage,
} from '../../types.js';
import type {
  Agent,
  HookSupport,
  TranscriptAnalyzer,
  TokenCalculator,
  TranscriptChunker,
} from '../types.js';
import { registerAgent } from '../registry.js';

// ============================================================================
// Constants
// ============================================================================

const OPENCODE_DIR = '.opencode';

const HOOK_NAMES = [
  'session-start',
  'session-end',
  'turn-start',
  'turn-end',
  'compaction',
] as const;

/** Tools that modify files in OpenCode */
const FILE_MODIFICATION_TOOLS = new Set(['edit', 'write', 'patch']);

const RUNLOG_PLUGIN_MARKER = 'Auto-generated by `runlog enable --agent opencode`';

// ============================================================================
// OpenCode Export JSON Types
// ============================================================================

export interface ExportSession {
  info: SessionInfo;
  messages: ExportMessage[];
}

export interface SessionInfo {
  id: string;
  title?: string;
  createdAt?: number;
  updatedAt?: number;
}

export interface ExportMessage {
  info: MessageInfo;
  parts: Part[];
}

export interface MessageInfo {
  id: string;
  sessionID?: string;
  role: string;
  time: { created: number; completed?: number };
  tokens?: {
    input: number;
    output: number;
    reasoning: number;
    cache: { read: number; write: number };
  };
  cost?: number;
}

export interface Part {
  type: string;
  text?: string;
  tool?: string;
  callID?: string;
  state?: ToolState;
}

export interface ToolState {
  status: string;
  input?: Record<string, unknown>;
  output?: string;
}

// ============================================================================
// OpenCode Agent Implementation
// ============================================================================

class OpenCodeAgent
  implements Agent, HookSupport, TranscriptAnalyzer, TokenCalculator, TranscriptChunker
{
  readonly name = AGENT_NAMES.OPENCODE;
  readonly type = AGENT_TYPES.OPENCODE;
  readonly description = 'OpenCode - AI-powered terminal coding agent';
  readonly isPreview = true;
  readonly protectedDirs = [OPENCODE_DIR];

  async detectPresence(cwd?: string): Promise<boolean> {
    const repoRoot = cwd ?? process.cwd();
    try {
      await fs.promises.stat(path.join(repoRoot, OPENCODE_DIR));
      return true;
    } catch {
      try {
        await fs.promises.stat(path.join(repoRoot, 'opencode.json'));
        return true;
      } catch {
        return false;
      }
    }
  }

  async getSessionDir(repoPath: string): Promise<string> {
    if (process.env.RUNLOG_TEST_OPENCODE_PROJECT_DIR) {
      return process.env.RUNLOG_TEST_OPENCODE_PROJECT_DIR;
    }
    const projectDir = sanitizePathForOpenCode(repoPath);
    return path.join(os.tmpdir(), 'runlog-opencode', projectDir);
  }

  getSessionID(input: HookInput): string {
    return input.sessionID;
  }

  resolveSessionFile(sessionDir: string, agentSessionID: string): string {
    return path.join(sessionDir, `${agentSessionID}.json`);
  }

  async readTranscript(sessionRef: string): Promise<Buffer> {
    return fs.promises.readFile(sessionRef);
  }

  formatResumeCommand(sessionID: string): string {
    if (!sessionID.trim()) return 'opencode';
    return `opencode -s ${sessionID}`;
  }

  // ===========================================================================
  // HookSupport
  // ===========================================================================

  hookNames(): string[] {
    return [...HOOK_NAMES];
  }

  parseHookEvent(hookName: string, stdin: string): Event | null {
    try {
      const data = JSON.parse(stdin) as Record<string, unknown>;
      const sessionID = String(data.session_id ?? data.sessionID ?? '');

      switch (hookName) {
        case 'session-start':
          return {
            type: EventType.SessionStart,
            sessionID,
            sessionRef: '',
            timestamp: new Date(),
          };

        case 'turn-start':
          return {
            type: EventType.TurnStart,
            sessionID,
            sessionRef: '',
            prompt: String(data.prompt ?? ''),
            timestamp: new Date(),
          };

        case 'turn-end':
          return {
            type: EventType.TurnEnd,
            sessionID,
            sessionRef: '',
            timestamp: new Date(),
          };

        case 'compaction':
          return {
            type: EventType.Compaction,
            sessionID,
            sessionRef: '',
            timestamp: new Date(),
          };

        case 'session-end':
          return {
            type: EventType.SessionEnd,
            sessionID,
            sessionRef: '',
            timestamp: new Date(),
          };

        default:
          return null;
      }
    } catch {
      return null;
    }
  }

  async installHooks(repoPath: string, force = false): Promise<number> {
    const pluginPath = path.join(repoPath, OPENCODE_DIR, 'plugins', 'runlog.ts');

    // Check if already installed
    if (!force) {
      try {
        const content = await fs.promises.readFile(pluginPath, 'utf-8');
        if (content.includes(RUNLOG_PLUGIN_MARKER)) return 0;
      } catch {
        // File doesn't exist, proceed with install
      }
    }

    // Create plugin directory
    await fs.promises.mkdir(path.dirname(pluginPath), { recursive: true });

    // Write the plugin file
    const pluginContent = generateOpenCodePlugin();
    await fs.promises.writeFile(pluginPath, pluginContent, 'utf-8');

    return 5; // 5 lifecycle hooks
  }

  async uninstallHooks(repoPath: string): Promise<void> {
    const pluginPath = path.join(repoPath, OPENCODE_DIR, 'plugins', 'runlog.ts');
    try {
      const content = await fs.promises.readFile(pluginPath, 'utf-8');
      if (content.includes(RUNLOG_PLUGIN_MARKER)) {
        await fs.promises.unlink(pluginPath);
      }
    } catch {
      // File doesn't exist
    }
  }

  async areHooksInstalled(repoPath: string): Promise<boolean> {
    const pluginPath = path.join(repoPath, OPENCODE_DIR, 'plugins', 'runlog.ts');
    try {
      const content = await fs.promises.readFile(pluginPath, 'utf-8');
      return content.includes(RUNLOG_PLUGIN_MARKER);
    } catch {
      return false;
    }
  }

  // ===========================================================================
  // TranscriptAnalyzer
  // ===========================================================================

  async getTranscriptPosition(transcriptPath: string): Promise<number> {
    try {
      const data = await fs.promises.readFile(transcriptPath, 'utf-8');
      const session = JSON.parse(data) as ExportSession;
      return session.messages?.length ?? 0;
    } catch {
      return 0;
    }
  }

  async extractModifiedFilesFromOffset(
    transcriptPath: string,
    startOffset: number,
  ): Promise<{ files: string[]; currentPosition: number }> {
    const data = await fs.promises.readFile(transcriptPath, 'utf-8');
    const session = JSON.parse(data) as ExportSession;
    const files = new Set<string>();

    for (let i = startOffset; i < session.messages.length; i++) {
      const msg = session.messages[i];
      if (msg.info.role !== 'assistant') continue;

      for (const part of msg.parts) {
        if (part.type !== 'tool' || !part.state) continue;
        if (!FILE_MODIFICATION_TOOLS.has(part.tool ?? '')) continue;

        const filePath = extractOpenCodeFilePath(part.state.input ?? {});
        if (filePath) files.add(filePath);
      }
    }

    return { files: Array.from(files), currentPosition: session.messages.length };
  }

  async extractPrompts(sessionRef: string, fromOffset: number): Promise<string[]> {
    const data = await fs.promises.readFile(sessionRef, 'utf-8');
    const session = JSON.parse(data) as ExportSession;
    const prompts: string[] = [];

    for (let i = fromOffset; i < session.messages.length; i++) {
      const msg = session.messages[i];
      if (msg.info.role !== 'user') continue;
      const content = extractTextFromParts(msg.parts);
      if (content) prompts.push(content);
    }

    return prompts;
  }

  async extractSummary(sessionRef: string): Promise<string> {
    const data = await fs.promises.readFile(sessionRef, 'utf-8');
    const session = JSON.parse(data) as ExportSession;

    for (let i = session.messages.length - 1; i >= 0; i--) {
      const msg = session.messages[i];
      if (msg.info.role === 'assistant') {
        const content = extractTextFromParts(msg.parts);
        if (content) return content;
      }
    }

    return '';
  }

  // ===========================================================================
  // TokenCalculator
  // ===========================================================================

  async calculateTokenUsage(transcriptData: Buffer, fromOffset: number): Promise<TokenUsage> {
    const usage = emptyTokenUsage();

    try {
      const session = JSON.parse(transcriptData.toString('utf-8')) as ExportSession;

      for (let i = fromOffset; i < session.messages.length; i++) {
        const msg = session.messages[i];
        if (msg.info.role !== 'assistant' || !msg.info.tokens) continue;

        usage.inputTokens += msg.info.tokens.input ?? 0;
        usage.outputTokens += msg.info.tokens.output ?? 0;
        usage.cacheReadTokens += msg.info.tokens.cache?.read ?? 0;
        usage.cacheCreationTokens += msg.info.tokens.cache?.write ?? 0;
        usage.apiCallCount++;
      }
    } catch {
      // Invalid transcript data
    }

    return usage;
  }

  // ===========================================================================
  // TranscriptChunker
  // ===========================================================================

  async chunkTranscript(content: Buffer, maxSize: number): Promise<Buffer[]> {
    try {
      const session = JSON.parse(content.toString('utf-8')) as ExportSession;
      if (!session.messages?.length) return [content];

      const infoStr = JSON.stringify(session.info);
      const baseSize = Buffer.byteLength(`{"info":${infoStr},"messages":[]}`);

      const chunks: Buffer[] = [];
      let currentMessages: ExportMessage[] = [];
      let currentSize = baseSize;

      for (const msg of session.messages) {
        const msgStr = JSON.stringify(msg);
        const msgSize = Buffer.byteLength(msgStr) + 1; // +1 for comma

        if (currentSize + msgSize > maxSize && currentMessages.length > 0) {
          chunks.push(
            Buffer.from(JSON.stringify({ info: session.info, messages: currentMessages })),
          );
          currentMessages = [];
          currentSize = baseSize;
        }

        currentMessages.push(msg);
        currentSize += msgSize;
      }

      if (currentMessages.length > 0) {
        chunks.push(Buffer.from(JSON.stringify({ info: session.info, messages: currentMessages })));
      }

      return chunks.length > 0 ? chunks : [content];
    } catch {
      return [content];
    }
  }

  async reassembleTranscript(chunks: Buffer[]): Promise<Buffer> {
    const allMessages: ExportMessage[] = [];
    let sessionInfo: SessionInfo | undefined;

    for (const chunk of chunks) {
      const session = JSON.parse(chunk.toString('utf-8')) as ExportSession;
      if (!sessionInfo) sessionInfo = session.info;
      allMessages.push(...(session.messages ?? []));
    }

    return Buffer.from(JSON.stringify({ info: sessionInfo ?? { id: '' }, messages: allMessages }));
  }
}

// ============================================================================
// Helpers
// ============================================================================

const nonAlphanumericRegex = /[^a-zA-Z0-9]/g;

function sanitizePathForOpenCode(repoPath: string): string {
  return repoPath.replace(nonAlphanumericRegex, '-');
}

function extractOpenCodeFilePath(input: Record<string, unknown>): string {
  for (const key of ['filePath', 'path']) {
    if (typeof input[key] === 'string' && input[key]) return input[key] as string;
  }
  return '';
}

/**
 * Extract text content from OpenCode message parts.
 */
export function extractTextFromParts(parts: Part[]): string {
  const texts: string[] = [];
  for (const part of parts) {
    if (part.type === 'text' && part.text) {
      texts.push(part.text);
    }
  }
  return texts.join('\n');
}

/**
 * Parse an OpenCode export session from raw bytes.
 */
export function parseExportSession(data: Buffer | string): ExportSession | null {
  const str = typeof data === 'string' ? data : data.toString('utf-8');
  if (!str.trim()) return null;
  return JSON.parse(str) as ExportSession;
}

/**
 * Extract all user prompts from raw export JSON.
 */
export function extractAllUserPrompts(data: Buffer | string): string[] {
  const session = parseExportSession(data);
  if (!session) return [];

  const prompts: string[] = [];
  for (const msg of session.messages) {
    if (msg.info.role !== 'user') continue;
    const content = extractTextFromParts(msg.parts);
    if (content) prompts.push(content);
  }
  return prompts;
}

/**
 * Generate the OpenCode plugin TypeScript source.
 */
function generateOpenCodePlugin(): string {
  return `// ${RUNLOG_PLUGIN_MARKER}
// This plugin integrates OpenCode with Runlog for session tracking.
// Do not edit manually.

import type { Plugin } from "opencode";

const plugin: Plugin = {
  name: "runlog",
  hooks: {
    "session.start": async ({ session }) => {
      const payload = JSON.stringify({ session_id: session.id });
      const proc = Bun.spawn(["runlog", "hooks", "opencode", "session-start"], {
        stdin: new Blob([payload]),
        stdout: "ignore",
        stderr: "ignore",
      });
      await proc.exited;
    },
    "session.end": async ({ session }) => {
      const payload = JSON.stringify({ session_id: session.id });
      const proc = Bun.spawn(["runlog", "hooks", "opencode", "session-end"], {
        stdin: new Blob([payload]),
        stdout: "ignore",
        stderr: "ignore",
      });
      await proc.exited;
    },
    "message.create": async ({ message, session }) => {
      if (message.role === "user") {
        const text = message.parts
          .filter((p: { type: string }) => p.type === "text")
          .map((p: { text: string }) => p.text)
          .join("\\n");
        const payload = JSON.stringify({ session_id: session.id, prompt: text });
        const proc = Bun.spawn(["runlog", "hooks", "opencode", "turn-start"], {
          stdin: new Blob([payload]),
          stdout: "ignore",
          stderr: "ignore",
        });
        await proc.exited;
      }
    },
    "message.complete": async ({ message, session }) => {
      if (message.role === "assistant") {
        const payload = JSON.stringify({ session_id: session.id });
        const proc = Bun.spawn(["runlog", "hooks", "opencode", "turn-end"], {
          stdin: new Blob([payload]),
          stdout: "ignore",
          stderr: "ignore",
        });
        await proc.exited;
      }
    },
  },
};

export default plugin;
`;
}

// ============================================================================
// Registration
// ============================================================================

export function createOpenCodeAgent(): OpenCodeAgent {
  return new OpenCodeAgent();
}

registerAgent(AGENT_NAMES.OPENCODE, () => new OpenCodeAgent());
